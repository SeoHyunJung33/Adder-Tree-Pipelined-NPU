# Adder-Tree-Pipelined-NPU

 1. Adder Tree 구조 적용

대안으로 채택된 Adder Tree(AT)는 각 덧셈 단계 사이에 레지스터를 삽입하기에 적합한 구조로, 레지스터 증가에 따른 면적 상승이라는 트레이드오프가 있으나 긴 연산 경로를 다수의 클록 사이클로 분할하여 최대 동작 주파수(Fmax)와 타이밍 여유를 향상시킨다. 또한 규격화된 트리 토폴로지와 짧아진 배선 구간은 라우팅 효율을 높여 동적 전력 소모를 줄이고, 배치·배선 과정의 예측 가능성을 개선한다.

본 설계는 5×5 커널에서 생성된 25개 곱셈 결과를 균형형 파이프라인드 AT로 25→13→7→4→2→1 단계로 축약한다. 각 단계는 두 항을 가산하고 홀수로 남는 항은 다음 단계로 전달(pass-up)하여 균형을 유지하며, 단계 사이 레지스터로 스테이지당 가산기 1개만 통과하도록 제한한다. 파이프라인 지연은 LAT_TOT = MUL_LAT + 5 + POST로 정의하고, 출력 데이터와 동기화를 위해 valid 신호를 동일 길이로 지연시켰다. 다채널(conv2) 환경에서는 채널별 파이프라인 깊이를 일치시키고 valid를 동기화하여 동일 좌표의 결과가 한 싸이클에 정렬되도록 하였다. 비트폭은 입력폭(IN_W)에 ⌈log₂25⌉를 더한 SUM_W = IN_W + 5로 설정하여 오버플로를 방지하면서 가산기 폭과 캐리 체인을 최소화하였다(모든 연산은 signed 일관성 유지).

시뮬레이션 결과, 임펄스 입력으로 측정한 지연이 계산된 LAT_TOT와 일치하였고, 난수 벡터에 대해 소프트웨어 기준 모델(동일 라운딩·쉬프트·포화 규칙)과 RTL 출력이 싸이클 단위로 일치하였다. 포화 경계 및 부호 혼합 입력에서도 기대 동작이 확인되었다. 종합하면, 균형형 트리–단계별 파이프라인–최소 필요 비트폭이라는 원칙을 통해 고클록 타이밍 안정성과 면적·전력 효율을 동시에 달성하였으며, 유효 신호 정렬 규약으로 상위 모듈 통합의 신뢰성 또한 확보하였다.

  1) conv1.v, conv2.v
     
<img width="589" height="336" alt="image" src="https://github.com/user-attachments/assets/333ea524-6813-4a5c-8749-2b64c2b8a9bb" />

[그림 1] Adder Tree Pipelining Simulation
Ref 코드는 한 출력당 N 사이클이 필요하지만, 개선한 conv 코드는 모든 곱을 동시에 만들고, Adder 
tree pipe로 넘겨 합산하게 하여 곱셈기에서 바로 다음 곱을 실행할 수 있어서, 파이프라인이 충전
되면 매 사이클 1출력까지 가능하게 하였다. load_done 변수를 통해 BRAM에 10워드가 실제 커밋 완
료되었다는 것을 알리고, fire_calc 신호을 통해 한 출력 계산을 시동하는 펄스를 내보낸다. 그리고 
vpipe 배열을 만들어서, 0이면 데이터 로드, 1이면 곱셈, 2이면 합산 이런 식으로 각 단계에 맞는 연
산을 할 수 있도록 구현하였다.

2) fc.v
   
<img width="645" height="242" alt="image" src="https://github.com/user-attachments/assets/022b2ed5-f830-410d-b4d3-894d4e2243db" />

[그림 2] 

conv1, conv2 layer를 구성한 후 시뮬레이션을 돌렸을 때, wns에 가장 많은 영향을 주는 fc.v라는 것
을 알게 되었다. fc에서는 48개의 곱을 총 10번을 수행하기 때문에 상당히 많은 타이밍 이슈가 생긴
다는 것을 알게 되어서 fc는 FILL→COMPUTE 두 단계와 10단 파이프라인으로 구성했다. 3채널 12비
트 입력을 14비트로 부호 확장해 48칸 버퍼에 16사이클 동안 채우고, 연산 단계에서는 뉴런 인덱스를 
순회하며 파이프라인이 찬 뒤 매 사이클 1개 출력이 나오도록 했다. 가중치는 뉴런 행 단위(384b/행)
로 온칩 BRAM에 로드하고, 마지막 행의 쓰기 신호를 한 사이클 더 유지해 커밋을 보장했다. 읽기는 
동기식(1클럭 지연)으로 받아 병렬 곱셈 → 균형형 덧셈 트리 → 바이어스·스케일 순서로 흐르며, 결과
값과 해당 뉴런 인덱스/유효 신호를 동일 지연만큼 함께 이동시켜 결과–뉴런 매칭을 보장했다. 내부는 
누산 폭을 넉넉히(약 28비트 수준) 유지해 오버플로·양자화 편향 가능성을 낮추는 방향을 택했다.

가중치 커밋 타이밍 불안정으로 생기던 X 전파와 첫 출력 정렬 불일치가 해소되었고, 큰 조합 경로를 
단계별로 끊으면서 worst slack이 이전보다 개선됐다. 다만 아직 음수 슬랙이 남아 있어, 파이프라인 
마지막을 바이어스 더하기와 시프트/슬라이스로 분리하고, 곱·누산 경로를 DSP 블록에 확실히 매핑하
는 방향으로 추가 단축을 진행할 계획이다. 동시에 덧셈 트리 후반에서 점진적 LSB 제거(반올림·가드
비트 유지)로 배선 폭을 줄이고, 384b 가중치 버스가 라우팅을 압박할 경우 시간 다중화를 검토한다. 
유효 신호는 첫 결과 마스킹 대신 카운터 기반 윈도우로 전환해 결과 개수를 정확히 보장하고, 레퍼
런스의 20→8비트 절삭과 본 설계의 넓은 내부 비트폭 사이에서 목표 주파수/정확도에 맞는 양자화 
규격을 최종 합의할 예정이다.

2. Comparator 파이프라이닝
   
CNN 연산 마지막에 fully connected에서 받은 10개의 수 중 최댓값을 골라 최종 decision을 출력하는 모듈 또한 초기 설계에서는 파이프라이닝이 명확하게 적용되어 있지 않아 파이프라이닝을 적용하여 개선하였다. 초기 설계의 비교기는 10개의 입력을 순차적으로 비교하는 선형적인 구조로, 이는 긴 조합 논리 경로를 유발하여 전체 시스템의 타이밍 성능에 좋지 않게 작용했다.

이 문제를 해결하기 위해, 토너먼트 방식의 파이프라인을 적용하여 구조를 개선했다. 기존의 선형 비교 방식과 동일하게 총 9개의 비교기를 사용하지만, 이를 4개의 파이프라인 스테이지로 나누어 배치하였다. 10개의 입력은 10개 → 5개 → 3개 → 2개 → 1개 의 과정으로 점진적으로 비교되어 최종 최댓값이 선택된다. 이 방식을 통해 긴 경로를 단축시켜 타이밍 개선, 최대 동작 주파수 개선, 전력 효율 개선을 기대하였다. 하지만 이 또한 레지스터가 추가 됨으로 인해 면적이 증가하는 트레이드오프가 발생하지만 명확한 이점을 위하여 감수하였다. 

<img width="538" height="234" alt="image" src="https://github.com/user-attachments/assets/fc339e71-1c64-420b-8e16-27ff3ca8e320" />

[그림 3] 비교기 파이프라이닝 파형


3. 최종 결과
   
 1) accuracy
    
<img width="750" height="181" alt="image" src="https://github.com/user-attachments/assets/104a8549-36bb-4e35-8d83-b3e476374ef3" />

[그림 4] 위) Reference Code, (아래) 개선된 Code

 2) area
    
<img width="696" height="248" alt="image" src="https://github.com/user-attachments/assets/8774f1c0-8aee-4ec4-9a56-2151238aeef7" />


[그림 5] (위) Reference Code, (아래) 개선된 Code

 3) worst slack
    
<img width="714" height="181" alt="image" src="https://github.com/user-attachments/assets/036f2acf-13a5-46ab-ac15-11175d8a54bf" />

[그림 6] (좌) Reference Code, (우) 개선된 Code

 4) power
    
 <img width="842" height="218" alt="image" src="https://github.com/user-attachments/assets/c5fde17b-5ab3-4f23-830c-ea65ec80c263" />

[그림 7] (좌) Reference Code, (우) 개선된 Code

최종적으로, 제안한 AT 기반 파이프라인 구조는 1,000장 실험에서 정확도가 96%→97%(+1%p)로 향상되고, post-synthesis 총 전력은 0.789 W→0.298 W(약 -62%)로 크게 감소했으며, worst slack은 -1618.61→-307.87로 절대값 기준 약 81% 개선되어 고클록 동작 가능성을 높였다. 반면 각 스테이지 사이 레지스터 삽입에 따른 비용으로 총 셀 면적은 23,033.88→38,269.58(약 +66%)로 증가했고, 순차 소자 면적도 1,773.51→7,448.86으로 확대되었다. 요약하면, 본 설계는 파이프라이닝으로 연산 경로를 단축하고 라우팅을 단순화하여 타이밍 여유와 전력 효율을 크게 개선하는 대신 면적 증가를 수용하는 명확한 트레이드오프를 보였으며, 향후 레지스터 재배치·컴프레서 트리 적용 및 합성 지시어 고정 등을 통해 잔여 음수 슬랙 해소와 면적 최적화가 가능하다.
